
 탑다운의 경우 시간복잡도를 계산하는 방식이 까다롭다.
 채워야 하는 칸의 수 - 메모 * 1 칸을 채우는 복잡도 계산
 
 * Dynamic programming
 두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.
 (1) Overlapping Subproblem
 - 부분 문제들이 겹쳐야 한다.
 - 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.
 - 문제를 작은 문제로 쪼갤 수 있다.
 - 쪼개진 작은 문제는 또 다른 큰 문제가 된다.
 (2) Optimal Substructure
 - 문제의 정답을 작은 문제의 정답에서 구할 수 있다.
 - 예 : 문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.
 - Optimal Substructure를 만족한다면, 크기에 상관없이 어떤 한 문제의 정답은 일정
 - 따라서 정답을 한 번 구했으면 Memoization 해 둔다.
 
 * Top down
 - 문제를 작은 문제로 나눈다.
 - 작은 문제를 푼다.
 - 작은 문제를 풀었으니, 이제 문제를 푼다.
 - 재귀 호출을 이용해서 문제를 쉽게 풀 수 있다.
 
 예) 피보나치 
 - 복잡도; 메모 채워야 하는 칸의 수 * 1칸을 채우는 복잡도 = N * O(1) = O(N)
 
 n 번째 피보나치 수를 구하기 위해서는
 작은 문제인 n-1 번째와 n-2 번째를 구한다.
 작은 문제를 풀었다면 n-1 번째와 n-2 번째를 더하여 문제를 푼다.
 
(1) memo가 없는 경우
int fibonnacci(int n){
  if(n <= 1){
    return n;
  }else{
    fibonnacci(n-1) + fibonnacci(n-2);
  }
}

(2) memo가 있는 경우 - 반드시 사용
메모를 읽고나서 써야한다.
int memo[100];
int fibonnacci(int n){
  if(n <= 1){
    return n;
  }else{
    if(memo[n] > 0){ // 존재한다면
      return memo[n]; 
    }
    memo[n] = fibonacci(n-1) + fibonnacci(n-2);
    return memo[n];
  }
}

* Bottom UP
- 문제를 크기가 작은 문제부터 차례대호 푼다.
- 문제의 크기를 조금씩 크게 만들면서 문제를 푼다.
- 반복하다보면 언젠간 큰 문제가 풀린다.
- 반복문을 사용하면 쉽게 구현 가능하다.

int d[100];
int fibonnacci(int n){
  d[0] = 0;
  d[1] = 1;
  for(int i = 2; i<=n; i++){
    d[i] = d[i-1] + d[i-2];
  }
  return d[n];
}

* 다이나믹 문제 풀이 전략
- 문제에서 구하려고 하는 답을 문장으로 나타낸다.
- 예 : 피보나치 수를 구하는 문제
- N 번째 피보나치 수
- 이제 그 문장에 나와있는 변수의 개수만큼 메모하는 배열을 만든다.
- Top-down인 경우에는 재귀 호출의 인자의 개수
- 문제를 작은 문제로 나누고, 수식을 이용해서 문제를 표현한다.

