푼 문제 : 
동전 0	https://www.acmicpc.net/problem/11047
회의실배정	https://www.acmicpc.net/problem/1931
ATM	https://www.acmicpc.net/problem/11399
잃어버린 괄호	https://www.acmicpc.net/problem/1541
수 묶기	https://www.acmicpc.net/problem/1744
대회 or 인턴	https://www.acmicpc.net/problem/2875
30	https://www.acmicpc.net/problem/10610
병든 나이트	https://www.acmicpc.net/problem/1783
NMK	https://www.acmicpc.net/problem/1201
행렬	https://www.acmicpc.net/problem/1080
롤러코스터	https://www.acmicpc.net/problem/2873

* 그리디 알고리즘
- 결정해야 할 때, 그 순간에 가장 좋다고 생각하는 것을 선택하며 답을 찾아가는 알고리즘
- 그 때 그 때는 최적일지도 모르지만, 최종적으론느 답이 최적이 아닐 수도 있다.
- 언제 써야 하는가? : 지금 이 순간 가장 좋은 경우를 선택하는 것이 항상 최적인 경우
                    , 수학적 수식으로 풀 수 있는 경우
- 그것이 왜 최적이 되는지를 증명해야하기 때문에 어렵다.

11047번 : 동전 0	https://www.acmicpc.net/problem/11047

#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
	int n, k;
	scanf("%d %d", &n, &k);
	vector<int> a;
	int input;
	for (int i = 0; i < n; i++) {
		scanf("%d", &input);
		a.push_back(input);
	}
	int ans = 0;
	for (int i = n-1; i >= 0; i--) {
		while (k - a[i] >= 0) {
			k = k - a[i];
			ans += 1;
		}
		if (k == 0) break;
	}
	printf("%d\n", ans);
	return 0;
}

- 더 빠른 구현
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i=0; i<n; i++) {
        cin >> a[i];
    }
    int ans = 0;
    for (int i=n-1; i>=0; i--) {
        ans += k/a[i];
        k %= a[i];
    }
    cout << ans << '\n';
    return 0;
}

1931번 : https://www.acmicpc.net/problem/1931
- 고려해야 할 것 : 끝나는 시간과 시작하는 시간이 같은 경우 -> lambda
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
struct Meeting {
	int begin, end;
};
int main() {
	int n;
	scanf("%d", &n);
	vector<Meeting> a(n);
	for (int i = 0; i < n; i++) {
		scanf("%d %d", &a[i].begin, &a[i].end);
	}
	sort(a.begin(), a.end(), [](const Meeting &u, const Meeting &v) {
		if (u.end == v.end) {
			return u.begin < v.begin;
		}
		else {
			return u.end < v.end;
		}
		});
	int now = 0;
	int ans = 0;
	for (int i = 0; i < n; i++) {
		if (now <= a[i].begin) {
			now = a[i].end;
			ans += 1;
		}
	}
	printf("%d\n", ans);
	return 0;
}

